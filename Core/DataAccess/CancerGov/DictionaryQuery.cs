using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Linq;
using System.Text;

using Microsoft.Practices.EnterpriseLibrary.Data;
using Microsoft.Practices.EnterpriseLibrary.Data.Sql;

using NCI.Data;

using GateKeeper.DocumentObjects;
using GateKeeper.DocumentObjects.Dictionary;
using GateKeeper.DataAccess.StoreProcedures;

namespace GateKeeper.DataAccess.CancerGov
{
    /// <summary>
    /// This is a helper class, used by the GlossaryTermQuery and TerminologyQuery
    /// classes to implement the shared functionality of working with the Dictionary tables.
    /// Note that this class is intended to be used as a helper object and is not intended
    /// as a subclass of DocumentQuery.  The public method names match as matter of convience
    /// and clarity.
    /// </summary>
    class DictionaryQuery
    {
        const string SP_SAVE_DICTIONARY_TERM = "usp_SaveDictionaryTerm";
        const string SP_PUSH_TO_PREVIEW = "usp_PushDictionaryTermToPreview";
        const string SP_PUSH_TO_LIVE = "usp_PushDictionaryTermToLive";

        public void SaveDocument(int termId, List<GeneralDictionaryEntry> entries, DbTransaction transaction)
        {
            /// Verify the DbTransaction object we've been passed (generated by Enterprise Library classes)
            /// is actually a SqlTransaction.  This should always be true since we only run against MSSQL,
            /// but best to check the assumption.
            SqlTransaction sqlTransaction = transaction as SqlTransaction;
            if (sqlTransaction == null)
                throw new DatabaseAssumptionException("Unable to treat dbTransaction as SqlTransaction.");

            DataTable dictionary = new DataTable("dictionary");
            dictionary.Columns.Add("TermID", typeof(int));
            dictionary.Columns.Add("TermName", typeof(String));
            dictionary.Columns.Add("Dictionary", typeof(String));
            dictionary.Columns.Add("Language", typeof(String));
            dictionary.Columns.Add("Audience", typeof(String));
            dictionary.Columns.Add("ApiVers", typeof(String));
            dictionary.Columns.Add("Object", typeof(String));

            foreach (GeneralDictionaryEntry entry in entries)
            {
                dictionary.Rows.Add(entry.TermID, entry.TermName, entry.Dictionary, entry.Language, entry.Audience, entry.ApiVersion, entry.Object);
            }

            SqlParameter[] parameters = new SqlParameter[]{
                new SqlParameter("@TermID", SqlDbType.Int){Value = termId},
                new SqlParameter("@Entries", SqlDbType.Structured){Value = dictionary}
            };

            SqlHelper.ExecuteNonQuery(sqlTransaction, CommandType.StoredProcedure, SP_SAVE_DICTIONARY_TERM, parameters);
        }

        public void DeleteDocument(int termId, DbTransaction transaction)
        {
            /// Verify the DbTransaction object we've been passed (generated by Enterprise Library classes)
            /// is actually a SqlTransaction.  This should always be true since we only run against MSSQL,
            /// but best to check the assumption.
            SqlTransaction sqlTransaction = transaction as SqlTransaction;
            if (sqlTransaction == null)
                throw new DatabaseAssumptionException("Unable to treat dbTransaction as SqlTransaction.");

            throw new NotImplementedException();
        }

        public void PushDocumentToPreview(int termId, DbTransaction transaction)
        {
            /// Verify the DbTransaction object we've been passed (generated by Enterprise Library classes)
            /// is actually a SqlTransaction.  This should always be true since we only run against MSSQL,
            /// but best to check the assumption.
            SqlTransaction sqlTransaction = transaction as SqlTransaction;
            if (sqlTransaction == null)
                throw new DatabaseAssumptionException("Unable to treat dbTransaction as SqlTransaction.");

            SqlParameter[] parameters = new SqlParameter[]{
                new SqlParameter("@TermID", SqlDbType.Int){Value = termId}
            };

            int rc = SqlHelper.ExecuteNonQuery(sqlTransaction, CommandType.StoredProcedure, SP_PUSH_TO_PREVIEW, parameters);
        }

        public void PushDocumentToLive(int termId, DbTransaction transaction)
        {
            /// Verify the DbTransaction object we've been passed (generated by Enterprise Library classes)
            /// is actually a SqlTransaction.  This should always be true since we only run against MSSQL,
            /// but best to check the assumption.
            SqlTransaction sqlTransaction = transaction as SqlTransaction;
            if (sqlTransaction == null)
                throw new DatabaseAssumptionException("Unable to treat dbTransaction as SqlTransaction.");

            SqlParameter[] parameters = new SqlParameter[]{
                new SqlParameter("@TermID", SqlDbType.Int){Value = termId}
            };

            int rc = SqlHelper.ExecuteNonQuery(sqlTransaction, CommandType.StoredProcedure, SP_PUSH_TO_LIVE, parameters);
        }


        ///// <summary>
        ///// Not implemented.  It is an error, by design, to call SaveDBDocument on
        ///// objects of type DictionaryQuery.  Do not attempt to use the one in
        ///// the base class.
        ///// 
        ///// Dictionary objects do not appear in the Document table.
        ///// The GlossaryTermQuery and TerminologyQuery classes are responsible for
        ///// making their own calls.
        ///// </summary>
        ///// <param name="doc"></param>
        ///// <param name="db"></param>
        ///// <param name="transaction"></param>
        //new protected void SaveDBDocument(Document doc, Database db, DbTransaction transaction)
        //{
        //    throw new NotImplementedException();
        //}
    }
}
